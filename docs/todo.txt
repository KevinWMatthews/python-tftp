Should client tests create their own packets or use the various Packet classes? Probably the packet classes.

Allow variable MAX_DATA_SIZE. Where does it belong now?

I've hard-coded self.socket in Client's helper methods. This is fine for now (forever?).

Make ReadPacket mode default to octet.

For block number failure in client read:
    # print 'Received wrong block number! Expecting 1 but got %s' % block_number
    The block number is an unprintable character. How can I display the hex code?

Implement varying debug levels.

Implement server retries.
    The server can miss the client ack and sending the same packet again.
    Wonder how to test this in the real world. Maybe have a dummy socket that we can swap in somehow?

Handle error messages from server:
    File not found

DataPacket, format_string(),
    # Rather than trying to pack a variable amount of data into the struct,
    # we'll just insist that the data is in string format and concatenate the strings.
    # Is this assumption valid?

Misc:

Do we want to try to verify the console output of client read failures? Probably not.
Do we want to return an error message? Not sure yet. It is simpler to return false for now.

Should we combine server ip and port/tid into a single tuple, the socket address?

Revise random string generator to include all bytes of data, not just printable characters.

What really happens to element 4 in an empty data packet? Revisit this.

Is there a way to get rid of 'from socket import timeout' in Client.py? Can we somehow use socket.timeout?

Add options to Client initialization:
    mode
    filename
    port

Change import statments in tests? import tftp -> tftp.Client, tftp.ReadPacket, etc.



Scripts:
Modify random_string to produce a variable-length string.
Modify tftp_get to allow the user to enter a filename.
Specify/determine the download location.
Move testing scripts to a different folder. Also don't distribute.
